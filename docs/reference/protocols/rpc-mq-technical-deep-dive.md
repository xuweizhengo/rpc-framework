# RPC+MQ 技术深度解析与核心坑点

## 网络通信 (Netty核心)

### 深入思考方向

- **Reactor线程模型配置**
- **TCP粘包拆包处理**
- **心跳机制设计**
- **连接生命周期管理**
- **优雅关闭机制**
- **自定义协议编解码优化**
- **零拷贝应用(FileRegion)**

### 核心坑点

- **资源泄漏**：ByteBuf未release, Channel未close
- **线程模型配置不当**：导致性能瓶颈
- **心跳未正确处理**：假死连接问题
- **编解码错误**：导致数据错乱

## 序列化技术

### 深入思考方向

- **性能对比与选型**：Protobuf vs Kryo vs Hessian
- **跨语言支持**：Protobuf优势
- **兼容性设计**：字段增删处理
- **安全性**：如何避免Java序列化漏洞

### 核心坑点

- **循环引用**：导致栈溢出
- **大对象序列化**：性能问题
- **字段类型变更**：兼容性问题
- **字符编码**：未考虑编码问题

## 服务注册与发现

### 深入思考方向

- **健康检查机制**：客户端探活/服务端心跳
- **服务上下线通知机制**
- **缓存与更新策略**：避免每次调用都查注册中心
- **负载均衡感知节点变化**

### 核心坑点

- **注册中心单点故障**：考虑客户端缓存
- **服务实例状态不一致**：网络分区问题
- **通知丢失**：导致负载不均衡
- **慢注册/慢注销**：影响服务可用性

## 负载均衡策略

### 深入思考方向

**不同策略适用场景：**
- **随机**：适合均匀负载
- **轮询**：适合同构服务
- **加权**：适合异构服务
- **一致性Hash**：适合有状态服务
- **自适应负载**：动态感知服务提供者性能(难点)

### 核心坑点

- **负载不均**：策略缺陷或未考虑权重
- **新节点上线流量洪峰**：需要预热
- **慢节点拖累整体**：需熔断剔除

## 容错机制设计

### 超时控制

**深入思考方向：**
- 如何设置合理超时时间？
- 超时后连接/线程资源如何处理？

**核心坑点：**
- 超时设置不当导致级联故障

### 重试机制

**深入思考方向：**
- **幂等性设计**(重要！)
- **重试风暴**：避免指数级放大
- **退避策略**：线性/指数退避

**核心坑点：**
- 重试导致非幂等操作数据错乱

### 熔断机制

**深入思考方向：**
- **熔断器状态机**：Closed/Open/Half-Open
- **错误率/慢调用率阈值**
- **熔断后如何探测恢复**(Half-Open)
- 参考Hystrix/Sentinel设计

**核心坑点：**
- 熔断过于敏感/迟钝

## MQ存储设计 (最大难点与亮点)

### 深入思考方向

**内存 vs 文件：**
- 纯内存快但易失
- 文件持久但慢
- **混合存储是王道！**
- 内存写缓冲(CommitLog)，异步刷盘
- 文件存储结构设计(参考RocketMQ/Kafka: 顺序写CommitLog + 索引文件)

**高性能写入：**
- **顺序IO** (MappedByteBuffer/FileChannel)
- **批处理**
- **PageCache利用**

**高性能读取：**
- 内存消费
- 文件消费(零拷贝sendfile)
- 缓存预热

**消息删除：**
- 基于offset清理过期消息
- 文件存储时如何高效删除？
- 通常标记+定时合并

**可靠性保证：**
- **刷盘策略**：
  - 同步刷盘：强一致但慢
  - 异步刷盘：高性能但可能丢少量消息
- **主从复制**：保证Broker宕机时不丢消息

### 核心坑点

- **文件存储设计不当**：导致性能极差(随机IO)
- **内存溢出**(OOM)
- **消息丢失**：未刷盘/未复制
- **消息文件无限增长**
- **消费进度(offset)丢失或错误**
- **索引与数据不一致**

## MQ消息投递语义

### 深入思考方向

**至少一次(At Least Once)保证：**
- Broker持久化 + 消费者ACK

**精确一次(Exactly Once)实现：**
- 难度极高
- 需要分布式事务或幂等消费+事务性存储

### 核心坑点

- **重复消费**：网络重试导致
- **消息丢失**：ACK丢失前消费者宕机
- **顺序性难以保证**：多Queue/多消费者

## 并发与线程模型

### 深入思考方向

- **RPC Server端业务逻辑线程池隔离**：避免慢Provider拖垮Netty IO线程
- **MQ Broker端消息存储与投递的线程模型设计**：读写分离？
- **锁优化**：无锁队列？分段锁？
- **避免共享资源竞争**

### 核心坑点

- **线程死锁/活锁**
- **线程池配置不当**：导致阻塞或资源耗尽
- **锁竞争激烈**：导致性能瓶颈

## 资源管理与泄漏

### 深入思考方向

- **Netty ByteBuf池化管理**
- **文件句柄管理**
- **线程池管理**
- **连接池管理**
- 使用`-XX:NativeMemoryTracking`监控堆外内存

### 核心坑点

- **堆外内存泄漏**：未release ByteBuf
- **文件句柄泄漏**：未close
- **线程泄漏**
- **连接泄漏**

## 性能调优策略

### JVM调优

- **堆内存配置**：根据业务场景调整新生代/老年代比例
- **GC策略选择**：G1GC适合低延迟场景
- **堆外内存监控**：Netty大量使用堆外内存

### 网络调优

- **TCP参数优化**：SO_KEEPALIVE, TCP_NODELAY
- **Netty线程模型调优**：Boss/Worker线程数配置
- **连接池配置**：最大连接数、空闲超时

### 存储调优

- **文件存储优化**：顺序写、批量刷盘
- **内存缓存策略**：LRU、TTL配置
- **索引设计优化**：减少随机IO

## 监控与运维

### 关键指标

**RPC监控指标：**
- 调用量、成功率、平均/P99延迟
- 连接数、线程池状态
- 熔断器状态、重试次数

**MQ监控指标：**
- 生产/消费TPS
- 消息堆积量
- 磁盘使用率
- 消费延迟

### 故障排查

- **日志设计**：结构化日志，关键路径追踪
- **链路追踪**：集成Jaeger/Zipkin
- **性能诊断**：JVM性能分析工具使用