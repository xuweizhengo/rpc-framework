package com.rpcframework.examples.benchmark;

import com.rpcframework.examples.model.User;
import com.rpcframework.examples.service.UserService;
import com.rpcframework.examples.service.impl.UserServiceImpl;
import com.rpcframework.rpc.client.RpcClient;
import com.rpcframework.rpc.client.RpcFuture;
import com.rpcframework.rpc.config.NetworkConfig;
import com.rpcframework.rpc.model.RpcRequest;
import com.rpcframework.rpc.model.RpcResponse;
import com.rpcframework.rpc.server.RpcRequestHandler;
import com.rpcframework.rpc.server.RpcServer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

/**
 * RPC框架性能基准测试
 * 
 * <p>全面测试RPC框架的性能指标，包括QPS、延迟、吞吐量和资源使用情况。
 * 目标是达到单连接3000 QPS，99%延迟小于50ms的性能基线。
 * 
 * @author rpc-framework
 * @since 1.0.0
 */
public class RpcBenchmarkTest {
    
    private static final Logger logger = LoggerFactory.getLogger(RpcBenchmarkTest.class);
    
    private RpcServer server;\n    private List<RpcClient> clients;\n    private ExecutorService executorService;\n    \n    // 性能指标\n    private final AtomicLong totalRequests = new AtomicLong(0);\n    private final AtomicLong successRequests = new AtomicLong(0);\n    private final AtomicLong failedRequests = new AtomicLong(0);\n    private final List<Long> latencies = new CopyOnWriteArrayList<>();\n    \n    public static void main(String[] args) {\n        RpcBenchmarkTest benchmark = new RpcBenchmarkTest();\n        benchmark.runBenchmark();\n    }\n    \n    /**\n     * 运行基准测试\n     */\n    public void runBenchmark() {\n        logger.info(\"Starting RPC Framework Benchmark Test...\");\n        logger.info(\"Target: 3000 QPS, 99% latency < 50ms\");\n        \n        try {\n            // 1. 初始化测试环境\n            initializeTestEnvironment();\n            \n            // 2. 预热测试\n            warmupTest();\n            \n            // 3. 同步调用基准测试\n            runSyncBenchmark();\n            \n            // 4. 异步调用基准测试\n            runAsyncBenchmark();\n            \n            // 5. 并发连接测试\n            runConcurrentConnectionTest();\n            \n            // 6. 负载测试\n            runLoadTest();\n            \n            // 7. 延迟分布测试\n            runLatencyTest();\n            \n        } catch (Exception e) {\n            logger.error(\"Benchmark test failed\", e);\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * 初始化测试环境\n     */\n    private void initializeTestEnvironment() throws Exception {\n        logger.info(\"Initializing test environment...\");\n        \n        // 创建线程池\n        int threadCount = Runtime.getRuntime().availableProcessors() * 2;\n        executorService = Executors.newFixedThreadPool(threadCount, \n            r -> new Thread(r, \"benchmark-\" + System.nanoTime()));\n        \n        // 启动服务端\n        startBenchmarkServer();\n        \n        // 创建客户端连接池\n        createClientPool();\n        \n        logger.info(\"Test environment initialized successfully\");\n        logger.info(\"Server: localhost:8080\");\n        logger.info(\"Client pool size: {}\", clients.size());\n        logger.info(\"Thread pool size: {}\", threadCount);\n    }\n    \n    /**\n     * 启动性能测试服务端\n     */\n    private void startBenchmarkServer() throws Exception {\n        logger.info(\"Starting benchmark server...\");\n        \n        // 创建高性能服务端配置\n        NetworkConfig serverConfig = NetworkConfig.serverConfig()\n            .setServerPort(8080)\n            .setIoThreads(Runtime.getRuntime().availableProcessors())\n            .setWorkerThreads(Runtime.getRuntime().availableProcessors() * 2)\n            .setMaxConnections(2000)\n            .setUseEpoll(true)\n            .setTcpNodelay(true)\n            .setKeepAlive(true)\n            .setBacklog(1024)\n            .setRecvBufferSize(128 * 1024)\n            .setSendBufferSize(128 * 1024)\n            .setUsePooledAllocator(true);\n        \n        // 创建请求处理器并注册服务\n        RpcRequestHandler requestHandler = new RpcRequestHandler();\n        UserService userService = new UserServiceImpl();\n        requestHandler.registerService(UserService.class, userService);\n        \n        // 启动服务端\n        server = new RpcServer(serverConfig, requestHandler);\n        server.start();\n        \n        // 等待服务端启动\n        Thread.sleep(1000);\n        \n        logger.info(\"Benchmark server started on port 8080\");\n    }\n    \n    /**\n     * 创建客户端连接池\n     */\n    private void createClientPool() throws Exception {\n        logger.info(\"Creating client pool...\");\n        \n        int clientCount = 10; // 多个客户端连接\n        clients = new ArrayList<>(clientCount);\n        \n        // 创建高性能客户端配置\n        NetworkConfig clientConfig = NetworkConfig.clientConfig()\n            .setConnectTimeout(3000)\n            .setRequestTimeout(30000)\n            .setIoThreads(2)\n            .setUseEpoll(true)\n            .setTcpNodelay(true)\n            .setKeepAlive(true)\n            .setRecvBufferSize(128 * 1024)\n            .setSendBufferSize(128 * 1024)\n            .setUsePooledAllocator(true)\n            .setHeartbeatInterval(30000);\n        \n        // 创建并连接客户端\n        for (int i = 0; i < clientCount; i++) {\n            RpcClient client = new RpcClient(\"localhost\", 8080, clientConfig);\n            client.start();\n            client.connect();\n            clients.add(client);\n            \n            // 避免连接过快\n            Thread.sleep(100);\n        }\n        \n        logger.info(\"Created {} client connections\", clients.size());\n    }\n    \n    /**\n     * 预热测试\n     */\n    private void warmupTest() throws Exception {\n        logger.info(\"\\n=== Warmup Test ===\");\n        \n        int warmupRequests = 1000;\n        logger.info(\"Warming up with {} requests...\", warmupRequests);\n        \n        CountDownLatch latch = new CountDownLatch(warmupRequests);\n        long startTime = System.currentTimeMillis();\n        \n        for (int i = 0; i < warmupRequests; i++) {\n            RpcClient client = clients.get(i % clients.size());\n            \n            executorService.submit(() -> {\n                try {\n                    RpcRequest request = createTestRequest(\"getUserCount\", new Object[]{}, new Class[]{});\n                    RpcResponse response = client.sendRequest(request);\n                    \n                    if (response.isSuccess()) {\n                        // 预热成功\n                    }\n                } catch (Exception e) {\n                    // 忽略预热过程中的异常\n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n        \n        latch.await(30, TimeUnit.SECONDS);\n        long duration = System.currentTimeMillis() - startTime;\n        \n        logger.info(\"Warmup completed in {}ms\", duration);\n        \n        // 预热后暂停，让系统稳定\n        Thread.sleep(2000);\n    }\n    \n    /**\n     * 同步调用基准测试\n     */\n    private void runSyncBenchmark() throws Exception {\n        logger.info(\"\\n=== Synchronous Call Benchmark ===\");\n        \n        int[] requestCounts = {1000, 5000, 10000};\n        \n        for (int requestCount : requestCounts) {\n            logger.info(\"\\nTesting {} synchronous requests...\", requestCount);\n            \n            resetMetrics();\n            CountDownLatch latch = new CountDownLatch(requestCount);\n            long startTime = System.currentTimeMillis();\n            \n            for (int i = 0; i < requestCount; i++) {\n                final int requestId = i;\n                RpcClient client = clients.get(i % clients.size());\n                \n                executorService.submit(() -> {\n                    long requestStart = System.nanoTime();\n                    \n                    try {\n                        RpcRequest request = createTestRequest(\"getUserById\", \n                            new Object[]{(long) (requestId % 3 + 1)}, new Class[]{Long.class});\n                        \n                        RpcResponse response = client.sendRequest(request);\n                        \n                        long requestEnd = System.nanoTime();\n                        long latency = (requestEnd - requestStart) / 1_000_000; // ms\n                        latencies.add(latency);\n                        \n                        totalRequests.incrementAndGet();\n                        if (response.isSuccess()) {\n                            successRequests.incrementAndGet();\n                        } else {\n                            failedRequests.incrementAndGet();\n                        }\n                        \n                    } catch (Exception e) {\n                        failedRequests.incrementAndGet();\n                        totalRequests.incrementAndGet();\n                    } finally {\n                        latch.countDown();\n                    }\n                });\n            }\n            \n            boolean completed = latch.await(60, TimeUnit.SECONDS);\n            long duration = System.currentTimeMillis() - startTime;\n            \n            printBenchmarkResults(\"Sync\", requestCount, duration, completed);\n        }\n    }\n    \n    /**\n     * 异步调用基准测试\n     */\n    private void runAsyncBenchmark() throws Exception {\n        logger.info(\"\\n=== Asynchronous Call Benchmark ===\");\n        \n        int[] requestCounts = {1000, 5000, 10000};\n        \n        for (int requestCount : requestCounts) {\n            logger.info(\"\\nTesting {} asynchronous requests...\", requestCount);\n            \n            resetMetrics();\n            CountDownLatch latch = new CountDownLatch(requestCount);\n            long startTime = System.currentTimeMillis();\n            \n            for (int i = 0; i < requestCount; i++) {\n                final int requestId = i;\n                RpcClient client = clients.get(i % clients.size());\n                final long requestStart = System.nanoTime();\n                \n                try {\n                    RpcRequest request = createTestRequest(\"getUserById\", \n                        new Object[]{(long) (requestId % 3 + 1)}, new Class[]{Long.class});\n                    \n                    RpcFuture future = client.sendRequestAsync(request);\n                    \n                    future.onComplete(() -> {\n                        long requestEnd = System.nanoTime();\n                        long latency = (requestEnd - requestStart) / 1_000_000; // ms\n                        latencies.add(latency);\n                        \n                        totalRequests.incrementAndGet();\n                        if (future.isSuccess()) {\n                            successRequests.incrementAndGet();\n                        } else {\n                            failedRequests.incrementAndGet();\n                        }\n                        \n                        latch.countDown();\n                    });\n                    \n                } catch (Exception e) {\n                    failedRequests.incrementAndGet();\n                    totalRequests.incrementAndGet();\n                    latch.countDown();\n                }\n            }\n            \n            boolean completed = latch.await(60, TimeUnit.SECONDS);\n            long duration = System.currentTimeMillis() - startTime;\n            \n            printBenchmarkResults(\"Async\", requestCount, duration, completed);\n        }\n    }\n    \n    /**\n     * 并发连接测试\n     */\n    private void runConcurrentConnectionTest() throws Exception {\n        logger.info(\"\\n=== Concurrent Connection Test ===\");\n        \n        int concurrentLevel = 100;\n        int requestsPerThread = 50;\n        int totalRequests = concurrentLevel * requestsPerThread;\n        \n        logger.info(\"Testing {} concurrent threads, {} requests each\", concurrentLevel, requestsPerThread);\n        \n        resetMetrics();\n        CountDownLatch latch = new CountDownLatch(concurrentLevel);\n        long startTime = System.currentTimeMillis();\n        \n        for (int i = 0; i < concurrentLevel; i++) {\n            final int threadId = i;\n            \n            executorService.submit(() -> {\n                try {\n                    RpcClient client = clients.get(threadId % clients.size());\n                    \n                    for (int j = 0; j < requestsPerThread; j++) {\n                        long requestStart = System.nanoTime();\n                        \n                        try {\n                            RpcRequest request = createTestRequest(\"getUserCount\", new Object[]{}, new Class[]{});\n                            RpcResponse response = client.sendRequest(request);\n                            \n                            long requestEnd = System.nanoTime();\n                            long latency = (requestEnd - requestStart) / 1_000_000; // ms\n                            latencies.add(latency);\n                            \n                            totalRequests.incrementAndGet();\n                            if (response.isSuccess()) {\n                                successRequests.incrementAndGet();\n                            } else {\n                                failedRequests.incrementAndGet();\n                            }\n                            \n                        } catch (Exception e) {\n                            failedRequests.incrementAndGet();\n                            totalRequests.incrementAndGet();\n                        }\n                    }\n                    \n                } finally {\n                    latch.countDown();\n                }\n            });\n        }\n        \n        boolean completed = latch.await(120, TimeUnit.SECONDS);\n        long duration = System.currentTimeMillis() - startTime;\n        \n        printBenchmarkResults(\"Concurrent\", totalRequests, duration, completed);\n    }\n    \n    /**\n     * 负载测试\n     */\n    private void runLoadTest() throws Exception {\n        logger.info(\"\\n=== Load Test ===\");\n        \n        int duration = 30; // 30秒负载测试\n        AtomicInteger requestCount = new AtomicInteger(0);\n        \n        logger.info(\"Running load test for {} seconds...\", duration);\n        \n        resetMetrics();\n        long startTime = System.currentTimeMillis();\n        long endTime = startTime + duration * 1000;\n        \n        // 创建多个生产者线程\n        int producerCount = clients.size();\n        CountDownLatch producerLatch = new CountDownLatch(producerCount);\n        \n        for (int i = 0; i < producerCount; i++) {\n            final int producerId = i;\n            \n            executorService.submit(() -> {\n                try {\n                    RpcClient client = clients.get(producerId);\n                    \n                    while (System.currentTimeMillis() < endTime) {\n                        long requestStart = System.nanoTime();\n                        \n                        try {\n                            RpcRequest request = createTestRequest(\"getUserById\", \n                                new Object[]{(long) (requestCount.get() % 3 + 1)}, new Class[]{Long.class});\n                            \n                            RpcResponse response = client.sendRequest(request);\n                            \n                            long requestEnd = System.nanoTime();\n                            long latency = (requestEnd - requestStart) / 1_000_000; // ms\n                            latencies.add(latency);\n                            \n                            totalRequests.incrementAndGet();\n                            requestCount.incrementAndGet();\n                            \n                            if (response.isSuccess()) {\n                                successRequests.incrementAndGet();\n                            } else {\n                                failedRequests.incrementAndGet();\n                            }\n                            \n                        } catch (Exception e) {\n                            failedRequests.incrementAndGet();\n                            totalRequests.incrementAndGet();\n                        }\n                        \n                        // 小幅延迟避免过度负载\n                        Thread.sleep(1);\n                    }\n                    \n                } catch (InterruptedException e) {\n                    Thread.currentThread().interrupt();\n                } finally {\n                    producerLatch.countDown();\n                }\n            });\n        }\n        \n        // 等待负载测试完成\n        producerLatch.await();\n        long actualDuration = System.currentTimeMillis() - startTime;\n        \n        printBenchmarkResults(\"Load\", totalRequests.get(), actualDuration, true);\n    }\n    \n    /**\n     * 延迟分布测试\n     */\n    private void runLatencyTest() throws Exception {\n        logger.info(\"\\n=== Latency Distribution Test ===\");\n        \n        if (latencies.isEmpty()) {\n            logger.warn(\"No latency data available\");\n            return;\n        }\n        \n        // 排序延迟数据\n        List<Long> sortedLatencies = new ArrayList<>(latencies);\n        sortedLatencies.sort(Long::compareTo);\n        \n        int size = sortedLatencies.size();\n        if (size == 0) {\n            logger.warn(\"No latency data to analyze\");\n            return;\n        }\n        \n        // 计算统计指标\n        long min = sortedLatencies.get(0);\n        long max = sortedLatencies.get(size - 1);\n        long p50 = sortedLatencies.get(size / 2);\n        long p90 = sortedLatencies.get((int) (size * 0.9));\n        long p95 = sortedLatencies.get((int) (size * 0.95));\n        long p99 = sortedLatencies.get((int) (size * 0.99));\n        \n        double avg = sortedLatencies.stream().mapToLong(Long::longValue).average().orElse(0.0);\n        \n        logger.info(\"Latency Distribution Analysis:\");\n        logger.info(\"  Sample size: {}\", size);\n        logger.info(\"  Min: {}ms\", min);\n        logger.info(\"  Max: {}ms\", max);\n        logger.info(\"  Average: {:.2f}ms\", avg);\n        logger.info(\"  P50 (Median): {}ms\", p50);\n        logger.info(\"  P90: {}ms\", p90);\n        logger.info(\"  P95: {}ms\", p95);\n        logger.info(\"  P99: {}ms\", p99);\n        \n        // 检查是否达到性能目标\n        if (p99 <= 50) {\n            logger.info(\"✅ Performance target achieved: P99 <= 50ms\");\n        } else {\n            logger.warn(\"❌ Performance target missed: P99 = {}ms > 50ms\", p99);\n        }\n    }\n    \n    /**\n     * 创建测试请求\n     */\n    private RpcRequest createTestRequest(String methodName, Object[] parameters, Class<?>[] parameterTypes) {\n        RpcRequest request = new RpcRequest();\n        request.setInterfaceName(UserService.class.getName());\n        request.setMethodName(methodName);\n        request.setParameters(parameters);\n        request.setParameterTypes(parameterTypes);\n        return request;\n    }\n    \n    /**\n     * 重置性能指标\n     */\n    private void resetMetrics() {\n        totalRequests.set(0);\n        successRequests.set(0);\n        failedRequests.set(0);\n        latencies.clear();\n    }\n    \n    /**\n     * 打印基准测试结果\n     */\n    private void printBenchmarkResults(String testType, long requestCount, long duration, boolean completed) {\n        double qps = (double) totalRequests.get() / duration * 1000;\n        double successRate = (double) successRequests.get() / totalRequests.get() * 100;\n        double avgLatency = latencies.stream().mapToLong(Long::longValue).average().orElse(0.0);\n        \n        logger.info(\"{} Benchmark Results:\", testType);\n        logger.info(\"  Requested: {} calls\", requestCount);\n        logger.info(\"  Completed: {} calls\", totalRequests.get());\n        logger.info(\"  Successful: {} calls\", successRequests.get());\n        logger.info(\"  Failed: {} calls\", failedRequests.get());\n        logger.info(\"  Duration: {}ms\", duration);\n        logger.info(\"  QPS: {:.2f}\", qps);\n        logger.info(\"  Success Rate: {:.2f}%\", successRate);\n        logger.info(\"  Average Latency: {:.2f}ms\", avgLatency);\n        logger.info(\"  All Completed: {}\", completed);\n        \n        // 检查是否达到QPS目标\n        if (qps >= 3000) {\n            logger.info(\"✅ QPS target achieved: {:.2f} >= 3000\", qps);\n        } else {\n            logger.warn(\"❌ QPS target missed: {:.2f} < 3000\", qps);\n        }\n    }\n    \n    /**\n     * 清理测试资源\n     */\n    private void cleanup() {\n        logger.info(\"\\nCleaning up benchmark resources...\");\n        \n        // 关闭客户端\n        if (clients != null) {\n            for (RpcClient client : clients) {\n                try {\n                    if (client.isStarted()) {\n                        client.shutdown();\n                    }\n                } catch (Exception e) {\n                    logger.error(\"Error shutting down client\", e);\n                }\n            }\n        }\n        \n        // 关闭服务端\n        if (server != null && server.isStarted()) {\n            try {\n                server.shutdown();\n            } catch (Exception e) {\n                logger.error(\"Error shutting down server\", e);\n            }\n        }\n        \n        // 关闭线程池\n        if (executorService != null && !executorService.isShutdown()) {\n            executorService.shutdown();\n            try {\n                if (!executorService.awaitTermination(10, TimeUnit.SECONDS)) {\n                    executorService.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                executorService.shutdownNow();\n            }\n        }\n        \n        logger.info(\"Benchmark cleanup completed\");\n    }\n}