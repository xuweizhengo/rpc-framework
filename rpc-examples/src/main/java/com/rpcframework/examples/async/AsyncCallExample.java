package com.rpcframework.examples.async;

import com.rpcframework.examples.model.User;
import com.rpcframework.examples.service.UserService;
import com.rpcframework.rpc.client.RpcClient;
import com.rpcframework.rpc.client.RpcFuture;
import com.rpcframework.rpc.config.NetworkConfig;
import com.rpcframework.rpc.model.RpcRequest;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 异步调用示例
 * 
 * <p>展示RPC框架的异步调用能力，包括Future模式、回调机制和并发控制。
 * 演示了如何有效利用异步调用提升系统吞吐量和响应性。
 * 
 * @author rpc-framework
 * @since 1.0.0
 */
public class AsyncCallExample {
    
    private static final Logger logger = LoggerFactory.getLogger(AsyncCallExample.class);
    
    private RpcClient client;
    private ExecutorService executorService;
    
    public static void main(String[] args) {
        AsyncCallExample example = new AsyncCallExample();
        example.runAsyncExamples();
    }
    
    /**
     * 运行异步调用示例\n     */\n    public void runAsyncExamples() {\n        logger.info(\"Starting Async Call Examples...\");\n        \n        try {\n            // 1. 初始化\n            initialize();\n            \n            // 2. 基础异步调用\n            demonstrateBasicAsyncCall();\n            \n            // 3. 异步调用链\n            demonstrateAsyncCallChain();\n            \n            // 4. 并发异步调用\n            demonstrateConcurrentAsyncCalls();\n            \n            // 5. 异步批处理\n            demonstrateAsyncBatchProcessing();\n            \n            // 6. 异步调用超时处理\n            demonstrateAsyncTimeout();\n            \n            // 7. 异步调用异常处理\n            demonstrateAsyncExceptionHandling();\n            \n            // 8. CompletableFuture集成\n            demonstrateCompletableFutureIntegration();\n            \n        } catch (Exception e) {\n            logger.error(\"Error running async examples\", e);\n        } finally {\n            cleanup();\n        }\n    }\n    \n    /**\n     * 初始化客户端和线程池\n     */\n    private void initialize() throws Exception {\n        logger.info(\"Initializing async call example...\");\n        \n        // 创建高性能客户端配置\n        NetworkConfig config = NetworkConfig.clientConfig()\n            .setConnectTimeout(3000)\n            .setRequestTimeout(10000)\n            .setIoThreads(4)\n            .setUseEpoll(true)\n            .setTcpNodelay(true)\n            .setKeepAlive(true)\n            .setUsePooledAllocator(true);\n        \n        client = new RpcClient(\"localhost\", 8080, config);\n        client.start();\n        client.connect();\n        \n        // 创建线程池用于异步处理\n        executorService = Executors.newFixedThreadPool(10, \n            r -> new Thread(r, \"async-example-\" + System.nanoTime()));\n        \n        logger.info(\"Initialization completed\");\n    }\n    \n    /**\n     * 演示基础异步调用\n     */\n    private void demonstrateBasicAsyncCall() throws Exception {\n        logger.info(\"\\n=== Basic Async Call Example ===\");\n        \n        CountDownLatch latch = new CountDownLatch(1);\n        final long startTime = System.currentTimeMillis();\n        \n        // 发起异步调用\n        RpcFuture future = callUserServiceAsync(\"getUserCount\", new Object[]{}, new Class[]{});\n        \n        // 设置成功回调\n        future.onSuccess(() -> {\n            long duration = System.currentTimeMillis() - startTime;\n            try {\n                Object result = future.getResponse().getResult();\n                logger.info(\"Async call completed successfully in {}ms, result: {}\", duration, result);\n            } catch (Exception e) {\n                logger.error(\"Error processing async result\", e);\n            }\n            latch.countDown();\n        });\n        \n        // 设置失败回调\n        future.onFailure(() -> {\n            long duration = System.currentTimeMillis() - startTime;\n            logger.error(\"Async call failed in {}ms: {}\", duration, \n                future.getException() != null ? future.getException().getMessage() : \"Unknown error\");\n            latch.countDown();\n        });\n        \n        logger.info(\"Async call initiated, waiting for completion...\");\n        \n        // 等待完成\n        boolean completed = latch.await(5, TimeUnit.SECONDS);\n        if (!completed) {\n            logger.warn(\"Async call timed out\");\n        }\n    }\n    \n    /**\n     * 演示异步调用链\n     */\n    private void demonstrateAsyncCallChain() throws Exception {\n        logger.info(\"\\n=== Async Call Chain Example ===\");\n        \n        CountDownLatch latch = new CountDownLatch(1);\n        \n        // 第一步：获取用户总数\n        RpcFuture countFuture = callUserServiceAsync(\"getUserCount\", new Object[]{}, new Class[]{});\n        \n        countFuture.onSuccess(() -> {\n            try {\n                Long userCount = (Long) countFuture.getResponse().getResult();\n                logger.info(\"Step 1 completed: User count = {}\", userCount);\n                \n                // 第二步：获取第一个用户\n                RpcFuture userFuture = callUserServiceAsync(\"getUserById\", \n                    new Object[]{1L}, new Class[]{Long.class});\n                \n                userFuture.onSuccess(() -> {\n                    try {\n                        User user = (User) userFuture.getResponse().getResult();\n                        logger.info(\"Step 2 completed: Found user = {}\", \n                            user != null ? user.getUsername() : \"null\");\n                        \n                        // 第三步：根据用户名查找相似用户\n                        if (user != null) {\n                            RpcFuture findFuture = callUserServiceAsync(\"findUsersByUsername\", \n                                new Object[]{user.getUsername()}, new Class[]{String.class});\n                            \n                            findFuture.onComplete(() -> {\n                                try {\n                                    if (findFuture.isSuccess()) {\n                                        @SuppressWarnings(\"unchecked\")\n                                        List<User> users = (List<User>) findFuture.getResponse().getResult();\n                                        logger.info(\"Step 3 completed: Found {} similar users\", \n                                            users != null ? users.size() : 0);\n                                    } else {\n                                        logger.error(\"Step 3 failed: {}\", findFuture.getException().getMessage());\n                                    }\n                                } catch (Exception e) {\n                                    logger.error(\"Error in step 3\", e);\n                                }\n                                latch.countDown();\n                            });\n                        } else {\n                            logger.info(\"Skipping step 3 - no user found\");\n                            latch.countDown();\n                        }\n                    } catch (Exception e) {\n                        logger.error(\"Error in step 2\", e);\n                        latch.countDown();\n                    }\n                });\n                \n                userFuture.onFailure(() -> {\n                    logger.error(\"Step 2 failed: {}\", userFuture.getException().getMessage());\n                    latch.countDown();\n                });\n                \n            } catch (Exception e) {\n                logger.error(\"Error in step 1\", e);\n                latch.countDown();\n            }\n        });\n        \n        countFuture.onFailure(() -> {\n            logger.error(\"Step 1 failed: {}\", countFuture.getException().getMessage());\n            latch.countDown();\n        });\n        \n        // 等待整个调用链完成\n        boolean completed = latch.await(10, TimeUnit.SECONDS);\n        if (completed) {\n            logger.info(\"Async call chain completed successfully\");\n        } else {\n            logger.warn(\"Async call chain timed out\");\n        }\n    }\n    \n    /**\n     * 演示并发异步调用\n     */\n    private void demonstrateConcurrentAsyncCalls() throws Exception {\n        logger.info(\"\\n=== Concurrent Async Calls Example ===\");\n        \n        int concurrentCount = 10;\n        CountDownLatch latch = new CountDownLatch(concurrentCount);\n        AtomicInteger successCount = new AtomicInteger(0);\n        AtomicInteger failureCount = new AtomicInteger(0);\n        \n        long startTime = System.currentTimeMillis();\n        \n        // 发起多个并发异步调用\n        for (int i = 0; i < concurrentCount; i++) {\n            final int requestId = i;\n            \n            RpcFuture future = callUserServiceAsync(\"getUserById\", \n                new Object[]{(long) (requestId % 3 + 1)}, new Class[]{Long.class});\n            \n            future.onSuccess(() -> {\n                try {\n                    User user = (User) future.getResponse().getResult();\n                    logger.debug(\"Request {} completed: {}\", requestId, \n                        user != null ? user.getUsername() : \"null\");\n                    successCount.incrementAndGet();\n                } catch (Exception e) {\n                    logger.error(\"Error processing request {} result\", requestId, e);\n                    failureCount.incrementAndGet();\n                }\n                latch.countDown();\n            });\n            \n            future.onFailure(() -> {\n                logger.error(\"Request {} failed: {}\", requestId, \n                    future.getException() != null ? future.getException().getMessage() : \"Unknown error\");\n                failureCount.incrementAndGet();\n                latch.countDown();\n            });\n        }\n        \n        // 等待所有请求完成\n        boolean completed = latch.await(15, TimeUnit.SECONDS);\n        long duration = System.currentTimeMillis() - startTime;\n        \n        logger.info(\"Concurrent async calls completed:\");\n        logger.info(\"  Total requests: {}\", concurrentCount);\n        logger.info(\"  Successful: {}\", successCount.get());\n        logger.info(\"  Failed: {}\", failureCount.get());\n        logger.info(\"  Duration: {}ms\", duration);\n        logger.info(\"  All completed: {}\", completed);\n        \n        if (concurrentCount > 0) {\n            double qps = (double) concurrentCount / duration * 1000;\n            logger.info(\"  Effective QPS: {:.2f}\", qps);\n        }\n    }\n    \n    /**\n     * 演示异步批处理\n     */\n    private void demonstrateAsyncBatchProcessing() throws Exception {\n        logger.info(\"\\n=== Async Batch Processing Example ===\");\n        \n        // 准备批量数据\n        List<Long> userIds = List.of(1L, 2L, 3L, 999L); // 包含一个不存在的ID\n        CountDownLatch latch = new CountDownLatch(userIds.size());\n        List<User> results = new ArrayList<>();\n        \n        // 异步获取每个用户\n        for (Long userId : userIds) {\n            RpcFuture future = callUserServiceAsync(\"getUserById\", \n                new Object[]{userId}, new Class[]{Long.class});\n            \n            future.onComplete(() -> {\n                try {\n                    if (future.isSuccess()) {\n                        User user = (User) future.getResponse().getResult();\n                        if (user != null) {\n                            synchronized (results) {\n                                results.add(user);\n                            }\n                            logger.debug(\"Loaded user: {} (ID: {})\", user.getUsername(), user.getId());\n                        } else {\n                            logger.debug(\"User not found for ID: {}\", userId);\n                        }\n                    } else {\n                        logger.warn(\"Failed to load user {}: {}\", userId, \n                            future.getException().getMessage());\n                    }\n                } catch (Exception e) {\n                    logger.error(\"Error processing batch item {}\", userId, e);\n                }\n                latch.countDown();\n            });\n        }\n        \n        // 等待批处理完成\n        boolean completed = latch.await(10, TimeUnit.SECONDS);\n        \n        logger.info(\"Async batch processing completed:\");\n        logger.info(\"  Requested: {} users\", userIds.size());\n        logger.info(\"  Loaded: {} users\", results.size());\n        logger.info(\"  All completed: {}\", completed);\n        \n        results.forEach(user -> \n            logger.info(\"  - {}: {}\", user.getId(), user.getUsername()));\n    }\n    \n    /**\n     * 演示异步调用超时处理\n     */\n    private void demonstrateAsyncTimeout() throws Exception {\n        logger.info(\"\\n=== Async Timeout Handling Example ===\");\n        \n        CountDownLatch latch = new CountDownLatch(2);\n        \n        // 1. 正常调用（应该快速完成）\n        logger.info(\"1. Testing normal call...\");\n        RpcFuture normalFuture = callUserServiceAsync(\"slowOperation\", \n            new Object[]{100}, new Class[]{int.class});\n        \n        normalFuture.onComplete(() -> {\n            if (normalFuture.isSuccess()) {\n                logger.info(\"Normal call completed: {}\", normalFuture.getResponse().getResult());\n            } else {\n                logger.error(\"Normal call failed: {}\", normalFuture.getException().getMessage());\n            }\n            latch.countDown();\n        });\n        \n        // 2. 超时调用（故意设置很长的延迟）\n        logger.info(\"2. Testing timeout call...\");\n        RpcFuture timeoutFuture = callUserServiceAsync(\"slowOperation\", \n            new Object[]{15000}, new Class[]{int.class}); // 15秒延迟，会超时\n        \n        timeoutFuture.onComplete(() -> {\n            if (timeoutFuture.isSuccess()) {\n                logger.info(\"Timeout call unexpectedly completed: {}\", \n                    timeoutFuture.getResponse().getResult());\n            } else {\n                logger.info(\"Timeout call failed as expected: {}\", \n                    timeoutFuture.getException().getMessage());\n            }\n            latch.countDown();\n        });\n        \n        // 等待两个调用完成\n        boolean completed = latch.await(20, TimeUnit.SECONDS);\n        if (completed) {\n            logger.info(\"Timeout handling test completed\");\n        } else {\n            logger.warn(\"Timeout handling test itself timed out\");\n        }\n    }\n    \n    /**\n     * 演示异步调用异常处理\n     */\n    private void demonstrateAsyncExceptionHandling() throws Exception {\n        logger.info(\"\\n=== Async Exception Handling Example ===\");\n        \n        CountDownLatch latch = new CountDownLatch(3);\n        \n        // 1. 服务端异常\n        logger.info(\"1. Testing server exception...\");\n        RpcFuture exceptionFuture = callUserServiceAsync(\"testException\", \n            new Object[]{true}, new Class[]{boolean.class});\n        \n        exceptionFuture.onFailure(() -> {\n            logger.info(\"Server exception handled: {}\", exceptionFuture.getException().getMessage());\n            latch.countDown();\n        });\n        \n        // 2. 方法不存在\n        logger.info(\"2. Testing method not found...\");\n        RpcFuture notFoundFuture = callUserServiceAsync(\"nonExistentMethod\", \n            new Object[]{}, new Class[]{});\n        \n        notFoundFuture.onFailure(() -> {\n            logger.info(\"Method not found handled: {}\", notFoundFuture.getException().getMessage());\n            latch.countDown();\n        });\n        \n        // 3. 参数验证异常\n        logger.info(\"3. Testing parameter validation...\");\n        RpcFuture validationFuture = callUserServiceAsync(\"login\", \n            new Object[]{null, \"password\"}, new Class[]{String.class, String.class});\n        \n        validationFuture.onFailure(() -> {\n            logger.info(\"Validation error handled: {}\", validationFuture.getException().getMessage());\n            latch.countDown();\n        });\n        \n        // 等待异常处理完成\n        boolean completed = latch.await(10, TimeUnit.SECONDS);\n        if (completed) {\n            logger.info(\"Exception handling test completed\");\n        } else {\n            logger.warn(\"Exception handling test timed out\");\n        }\n    }\n    \n    /**\n     * 演示与CompletableFuture的集成\n     */\n    private void demonstrateCompletableFutureIntegration() throws Exception {\n        logger.info(\"\\n=== CompletableFuture Integration Example ===\");\n        \n        // 将RpcFuture转换为CompletableFuture\n        CompletableFuture<Long> userCountFuture = toCompletableFuture(\n            callUserServiceAsync(\"getUserCount\", new Object[]{}, new Class[]{})\n        ).thenApply(response -> (Long) response.getResult());\n        \n        CompletableFuture<User> userFuture = toCompletableFuture(\n            callUserServiceAsync(\"getUserById\", new Object[]{1L}, new Class[]{Long.class})\n        ).thenApply(response -> (User) response.getResult());\n        \n        // 组合两个Future\n        CompletableFuture<String> combinedFuture = userCountFuture\n            .thenCombine(userFuture, (count, user) -> {\n                String userName = user != null ? user.getUsername() : \"unknown\";\n                return String.format(\"Total users: %d, First user: %s\", count, userName);\n            });\n        \n        // 异步处理结果\n        combinedFuture.thenAccept(result -> {\n            logger.info(\"Combined result: {}\", result);\n        }).exceptionally(throwable -> {\n            logger.error(\"Combined operation failed\", throwable);\n            return null;\n        });\n        \n        // 等待完成\n        try {\n            String result = combinedFuture.get(10, TimeUnit.SECONDS);\n            logger.info(\"CompletableFuture integration completed successfully\");\n        } catch (Exception e) {\n            logger.error(\"CompletableFuture integration failed\", e);\n        }\n    }\n    \n    /**\n     * 将RpcFuture转换为CompletableFuture\n     */\n    private CompletableFuture<com.rpcframework.rpc.model.RpcResponse> toCompletableFuture(RpcFuture rpcFuture) {\n        CompletableFuture<com.rpcframework.rpc.model.RpcResponse> completableFuture = new CompletableFuture<>();\n        \n        rpcFuture.onSuccess(() -> {\n            try {\n                completableFuture.complete(rpcFuture.getResponse());\n            } catch (Exception e) {\n                completableFuture.completeExceptionally(e);\n            }\n        });\n        \n        rpcFuture.onFailure(() -> {\n            completableFuture.completeExceptionally(rpcFuture.getException());\n        });\n        \n        return completableFuture;\n    }\n    \n    /**\n     * 异步调用用户服务\n     */\n    private RpcFuture callUserServiceAsync(String methodName, Object[] parameters, Class<?>[] parameterTypes) \n            throws Exception {\n        RpcRequest request = new RpcRequest();\n        request.setInterfaceName(UserService.class.getName());\n        request.setMethodName(methodName);\n        request.setParameters(parameters);\n        request.setParameterTypes(parameterTypes);\n        \n        return client.sendRequestAsync(request);\n    }\n    \n    /**\n     * 清理资源\n     */\n    private void cleanup() {\n        logger.info(\"\\nCleaning up async example resources...\");\n        \n        if (executorService != null && !executorService.isShutdown()) {\n            executorService.shutdown();\n            try {\n                if (!executorService.awaitTermination(5, TimeUnit.SECONDS)) {\n                    executorService.shutdownNow();\n                }\n            } catch (InterruptedException e) {\n                Thread.currentThread().interrupt();\n                executorService.shutdownNow();\n            }\n        }\n        \n        if (client != null && client.isStarted()) {\n            try {\n                client.shutdown();\n            } catch (Exception e) {\n                logger.error(\"Error during client shutdown\", e);\n            }\n        }\n        \n        logger.info(\"Cleanup completed\");\n    }\n}